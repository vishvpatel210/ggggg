<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Archery Game - Stylish Edition</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: linear-gradient(to bottom, #051430, #092a55);
  }
  canvas {
    display: block;
    margin: auto;
    background: radial-gradient(circle at center, #15417a 0%, #021024 100%);
    box-shadow: 0 0 30px rgba(0,0,0,0.7);
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

let arrows = [];
let targets = [];
let isAiming = false;
let aimStart = null;
let aimEnd = null;
let score = 0;

function resizeCanvas() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
window.addEventListener("resize", resizeCanvas);

// Bow position (left side)
const bow = {
  x: 120,
  y: canvas.height / 2,
  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    // Bow body
    ctx.beginPath();
    const gradient = ctx.createLinearGradient(-20, -100, 20, 100);
    gradient.addColorStop(0, "#8B4513");
    gradient.addColorStop(1, "#A0522D");
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 8;
    ctx.lineCap = "round";
    ctx.moveTo(0, -100);
    ctx.quadraticCurveTo(-40, 0, 0, 100);
    ctx.stroke();

    // Bowstring (if aiming, draw stretched)
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#ddd";
    if (isAiming && aimEnd) {
      ctx.moveTo(0, -100);
      ctx.lineTo(aimEnd.x - this.x, aimEnd.y - this.y);
      ctx.lineTo(0, 100);
    } else {
      ctx.moveTo(0, -100);
      ctx.lineTo(0, 100);
    }
    ctx.stroke();
    ctx.restore();
  }
};

// Arrow class
class Arrow {
  constructor(x, y, angle, power) {
    this.x = x;
    this.y = y;
    this.vx = Math.cos(angle) * power;
    this.vy = Math.sin(angle) * power;
    this.angle = angle;
    this.active = true;
  }
  update() {
    this.vy += 0.3; // gravity
    this.x += this.vx;
    this.y += this.vy;
    this.angle = Math.atan2(this.vy, this.vx);
    if (this.x > canvas.width || this.y > canvas.height || this.y < 0) this.active = false;
  }
  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    // arrow shaft
    const gradient = ctx.createLinearGradient(0, 0, 40, 0);
    gradient.addColorStop(0, "#ffdd99");
    gradient.addColorStop(1, "#ff6600");
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-20, 0);
    ctx.lineTo(40, 0);
    ctx.stroke();

    // feather
    ctx.fillStyle = "#00ffff";
    ctx.beginPath();
    ctx.moveTo(-22, -3);
    ctx.lineTo(-28, 0);
    ctx.lineTo(-22, 3);
    ctx.closePath();
    ctx.fill();

    // tip
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.moveTo(42, 0);
    ctx.lineTo(36, -4);
    ctx.lineTo(36, 4);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }
}

// Target class
class Target {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.r = 35;
  }
  draw(ctx) {
    const colors = ["#fff", "#f00", "#ff0", "#0f0"];
    for (let i = 0; i < colors.length; i++) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r - i * 8, 0, Math.PI * 2);
      ctx.fillStyle = colors[i];
      ctx.fill();
    }
  }
}

function spawnTarget() {
  const y = 150 + Math.random() * (canvas.height - 300);
  targets.push(new Target(canvas.width - 150, y));
}
spawnTarget();

function drawTrajectory(ctx, start, end) {
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  const angle = Math.atan2(dy, dx);
  const dist = Math.min(Math.hypot(dx, dy), 250);
  const power = dist * 0.3;
  ctx.setLineDash([6, 8]);
  ctx.strokeStyle = "#00ffff";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(start.x, start.y);
  let px = start.x;
  let py = start.y;
  let vx = Math.cos(angle) * power;
  let vy = Math.sin(angle) * power;
  for (let i = 0; i < 60; i++) {
    vx *= 0.99; // slight air resistance
    vy += 0.3;  // gravity
    px += vx * 0.3;
    py += vy * 0.3;
    ctx.lineTo(px, py);
    if (py > canvas.height) break;
  }
  ctx.stroke();
  ctx.setLineDash([]);
}

// Mouse controls
canvas.addEventListener("mousedown", e => {
  aimStart = { x: bow.x, y: bow.y };
  aimEnd = { x: e.offsetX, y: e.offsetY };
  isAiming = true;
});
canvas.addEventListener("mousemove", e => {
  if (isAiming) aimEnd = { x: e.offsetX, y: e.offsetY };
});
canvas.addEventListener("mouseup", e => {
  if (!isAiming) return;
  const dx = e.offsetX - bow.x;
  const dy = e.offsetY - bow.y;
  const angle = Math.atan2(dy, dx);
  const power = Math.min(Math.hypot(dx, dy) * 0.3, 30);
  arrows.push(new Arrow(bow.x, bow.y, angle, power));
  isAiming = false;
});

function checkCollision(arrow, target) {
  const dist = Math.hypot(arrow.x - target.x, arrow.y - target.y);
  return dist < target.r;
}

function drawScore() {
  ctx.font = "22px Segoe UI";
  ctx.fillStyle = "#fff";
  ctx.fillText("Score: " + score, 20, 40);
}

function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  bow.draw(ctx);
  if (isAiming && aimEnd) drawTrajectory(ctx, { x: bow.x, y: bow.y }, aimEnd);
  for (let target of targets) target.draw(ctx);

  arrows.forEach(a => {
    a.update();
    a.draw(ctx);
    for (let t of targets) {
      if (checkCollision(a, t)) {
        score += 10;
        targets.splice(targets.indexOf(t), 1);
        arrows.splice(arrows.indexOf(a), 1);
        spawnTarget();
      }
    }
  });
  arrows = arrows.filter(a => a.active);
  drawScore();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
